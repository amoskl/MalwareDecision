from __future__ import division
from math import log


class Ngram(object):
    def __init__(self, ngram_str, proportion, good_proportion, bad_proportion):
        """
        @summary: initializes ngram object
        @parameter ngram_str : the ngram
        @parameter proportion : the proportion of all the files in the training set
                                that the ngram appears in them
        @parameter good_proportion : the proportion of all the "good" files in the training set
                                     that the ngram appears in them
        @parameter bad_proportion : the proportion of all the "bad" files in the training set
                                    that the ngram appears in them
        """
        self._ngram_str = ngram_str
        self._prop = proportion
        self._good_prop = good_proportion
        self._bad_prop = bad_proportion
        self._ig = 0.0

    @property
    def ngram_str(self):
        return self._ngram_str

    @property
    def proportion(self):
        return self._prop

    @property
    def good_prop(self):
        return self._good_prop

    @property
    def bad_prop(self):
        return self._bad_prop

    @property
    def ig(self):
        return self._ig

    @ig.setter
    def ig(self, value):
        self._ig = value


class Classifier(object):
    GOOD_FILES_PROP = 0
    BAD_FILES_PROP = 1
    RETURN_SIZE = 2

    def __init__(self, ngrams_apperances, bad_files_num, good_files_num):
        self._ngrams_apperances = ngrams_apperances
        self._bad_files_num = bad_files_num
        self._good_files_num = good_files_num
        self._files_num = bad_files_num + good_files_num
        self._good_files_proportion = good_files_num / (bad_files_num + good_files_num)
        self._bad_files_proportion = bad_files_num / (bad_files_num + good_files_num)
        self._ngrams_proportions = list()

    def _build_proportions_list(self):
        for ngram in self._ngrams_apperances:
            good_appearances = self._ngrams_apperances[ngram][0]
            bad_appearances = self._ngrams_apperances[ngram][1]
            good_prop = good_appearances / self._good_files_num
            bad_prop = bad_appearances / self._bad_files_num
            prop = (good_appearances + bad_appearances) / self._files_num
            ngram_prop = Ngram(ngram, prop, good_prop, bad_prop)
            self._ngrams_proportions.append(ngram_prop)

    @staticmethod
    def _calculate_element(p_vj_ci, p_vj, p_ci):
        if p_ci == 0 or p_vj == 0 or p_vj_ci == 0:
            return 0
        return p_vj_ci * log(p_vj_ci / (p_vj * p_ci))

    def _get_ngram_ig(self, ngram):
        app_in_good_files = self._calculate_element(ngram.good_prop, ngram.proportion, self._good_files_proportion)
        app_in_bad_files = self._calculate_element(ngram.bad_prop, ngram.proportion, self._bad_files_proportion)
        absence_from_good_files = self._calculate_element((1 - ngram.good_prop), (1 - ngram.proportion),
                                                          self._good_files_proportion)
        absence_from_bad_files = self._calculate_element((1 - ngram.bad_prop), (1 - ngram.proportion),
                                                         self._bad_files_proportion)
        ig = app_in_bad_files + app_in_good_files + absence_from_bad_files + absence_from_good_files
        return ig

    def get_most_informative_ngrams(self):
        self._build_proportions_list()
        for ngram in self._ngrams_proportions:
            ngram.ig = self._get_ngram_ig(ngram)

        #sort the ngrams according to their ig - from the bigger to smaller
        self._ngrams_proportions = sorted(self._ngrams_proportions, key=lambda current_ngram: (1 - current_ngram.ig))
        classified_ngrams = [ngram.ngram_str for ngram in self._ngrams_proportions[:self.RETURN_SIZE]]

        return classified_ngrams