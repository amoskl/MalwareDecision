from __future__ import division
from math import log
from sorted_collection import SortedCollection
from operator import itemgetter
from pprint import pprint


class Ngram(object):
    def __init__(self, ngram_str, proportion, good_proportion, bad_proportion):
        """
        @summary: initializes ngram object
        @parameter ngram_str : the ngram
        @parameter proportion : the proportion of all the files in the training set
                                that the ngram appears in them
        @parameter good_proportion : the proportion of all the "good" files in the training set
                                     that the ngram appears in them
        @parameter bad_proportion : the proportion of all the "bad" files in the training set
                                    that the ngram appears in them
        """
        self._ngram_str = ngram_str
        self._prop = proportion
        self._good_prop = good_proportion
        self._bad_prop = bad_proportion
        self._ig = 0.0

    @property
    def ngram_str(self):
        return self._ngram_str

    @property
    def proportion(self):
        return self._prop

    @property
    def good_prop(self):
        return self._good_prop

    @property
    def bad_prop(self):
        return self._bad_prop

    @property
    def ig(self):
        return self._ig

    @ig.setter
    def ig(self, value):
        self._ig = value


class Classifier(object):
    GOOD_FILES_PROP = 0
    BAD_FILES_PROP = 1
    RETURN_SIZE = 1000
    N = 4

    def __init__(self, bad_files_num, good_files_num):
        self._bad_files_num = bad_files_num
        self._good_files_num = good_files_num
        self._files_num = bad_files_num + good_files_num
        self._good_files_proportion = good_files_num / (bad_files_num + good_files_num)
        self._bad_files_proportion = bad_files_num / (bad_files_num + good_files_num)
        self._most_informative_ngrams = SortedCollection(key=itemgetter(1))

    @staticmethod
    def _calculate_element(p_vj_ci, p_vj, p_ci):
        if p_ci == 0 or p_vj == 0 or p_vj_ci == 0:
            return 0
            # a = p_vj * p_ci
        # b = (p_vj_ci / a)
        # c = log (b, 10)
        # d = p_vj_ci * c
        return p_vj_ci * log((p_vj_ci / (p_vj * p_ci)), 10)

    def _get_ngram_ig(self, ngram):
        app_in_good_files = self._calculate_element(ngram.good_prop, ngram.proportion, self._good_files_proportion)
        app_in_bad_files = self._calculate_element(ngram.bad_prop, ngram.proportion, self._bad_files_proportion)
        absence_from_good_files = self._calculate_element((1 - ngram.good_prop), (1 - ngram.proportion),
                                                          self._good_files_proportion)
        absence_from_bad_files = self._calculate_element((1 - ngram.bad_prop), (1 - ngram.proportion),
                                                         self._bad_files_proportion)
        ig = app_in_bad_files + app_in_good_files + absence_from_bad_files + absence_from_good_files
        return ig

    def _add_ngram_to_collection(self, ngram_item):
        self._most_informative_ngrams.insert(ngram_item)
        size = self._most_informative_ngrams.get_size()
        if size > Classifier.RETURN_SIZE:
            self._most_informative_ngrams.remove(self._most_informative_ngrams[Classifier.RETURN_SIZE])


        pprint(list(self._most_informative_ngrams))

    def add_new_ngram(self, ngram_str, good_appearances, bad_appearances):
        good_prop = good_appearances / self._good_files_num
        bad_prop = bad_appearances / self._bad_files_num
        prop = (good_appearances + bad_appearances) / self._files_num
        ngram = Ngram(ngram_str, prop, good_prop, bad_prop)
        ngram.ig = self._get_ngram_ig(ngram)
        ngram_item = (ngram.ngram_str, 1 - ngram.ig)
        print "adding ngram %s with ig %f\n\n:" % (ngram.ngram_str, ngram.ig, )
        self._add_ngram_to_collection(ngram_item)

    def get_most_informative_ngrams(self):
        classified_ngrams = [ngram[0] for ngram in list(self._most_informative_ngrams)]
        return classified_ngrams


class FileReader(object):
    SEPERATOR = '|'
    DEC_BASE = 16
    PARAMETERS_LENGTH = 9
    FILE_END  = ""

    def __init__(self, file_name):
        self._file_name = file_name
        self._good_files_num = 0
        self._bad_files_num = 0
        self._classifier = None

    def _parse_files_num(self, first_line):
        args = first_line.split(FileReader.SEPERATOR.encode('hex'))
        good_files_num = int(args[0].decode('hex'), FileReader.DEC_BASE)
        bad_files_num = int(args[1][:-2].decode('hex'), FileReader.DEC_BASE)
        self._classifier = Classifier(bad_files_num, good_files_num)

    def read_ngrams(self):
        i = 0
        with open(self._file_name, 'rb') as fp:
            files_num = fp.readline().encode('hex')
            self._parse_files_num(files_num)
            ngram_data = fp.read(FileReader.PARAMETERS_LENGTH + Classifier.N)
            if len(ngram_data) < FileReader.PARAMETERS_LENGTH + Classifier.N:
                ngram_data += fp.read(FileReader.PARAMETERS_LENGTH + Classifier.N - len(ngram_data))
            while ngram_data != FileReader.FILE_END:
                ngram_hex = ngram_data.encode('hex')
                ngram_str = ngram_hex[:(Classifier.N * 2)]
                print "ngram_hex is " + ngram_hex, "and num is ", i
                i += 1
                args = ngram_hex[(Classifier.N * 2):].split(FileReader.SEPERATOR.encode('hex'))
                ngram_good_appearances = int(args[1].decode('hex'), FileReader.DEC_BASE)
                ngram_bad_appearances = int(args[2].decode('hex'), FileReader.DEC_BASE)
                print "good id ", ngram_good_appearances, " and bad is ", ngram_bad_appearances
                self._classifier.add_new_ngram(ngram_str, ngram_good_appearances, ngram_bad_appearances)
                ngram_data = fp.read(FileReader.PARAMETERS_LENGTH + Classifier.N)
                if len(ngram_data) < FileReader.PARAMETERS_LENGTH + Classifier.N:
                    ngram_data += fp.read(FileReader.PARAMETERS_LENGTH + Classifier.N - len(ngram_data))

    def get_most_informative_ngrams(self):
        return self._classifier.get_most_informative_ngrams()
