from __future__ import division
from math import log
from operator import itemgetter
import time

from configuration import NUMBER_OF_NGRAMS_TO_BUILD_TREE, NGRAM_SIZE
from ngram_classificaiton.sorted_collection import SortedCollection


class Ngram(object):
    """
    represents a ngram
    """

    def __init__(self, ngram_str, proportion, good_proportion, bad_proportion):
        """
        @summary: initializes ngram object
        @parameter ngram_str : the ngram
        @parameter proportion : the proportion of all the files in the training set
                                that the ngram appears in them
        @parameter good_proportion : the proportion of all the "good" files in the training set
                                     that the ngram appears in them
        @parameter bad_proportion : the proportion of all the "bad" files in the training set
                                    that the ngram appears in them
        """
        self._ngram_str = ngram_str
        self._prop = proportion
        self._good_prop = good_proportion
        self._bad_prop = bad_proportion
        self._ig = 0.0

    @property
    def ngram_str(self):
        return self._ngram_str

    @property
    def proportion(self):
        return self._prop

    @property
    def good_prop(self):
        return self._good_prop

    @property
    def bad_prop(self):
        return self._bad_prop

    @property
    def ig(self):
        return self._ig

    @ig.setter
    def ig(self, value):
        self._ig = value


class Classifier(object):
    """
    calculates information_gram(ig) of ngrams , and holding a sorted collection
    that holds all the ngrams with the highest igs
    """
    GOOD_FILES_PROP = 0
    BAD_FILES_PROP = 1
    #the number of ngrams with highest igs that we return
    RETURN_SIZE = NUMBER_OF_NGRAMS_TO_BUILD_TREE

    #length(bytes) of ngram
    N = NGRAM_SIZE

    def __init__(self, bad_files_num, good_files_num):
        self._bad_files_num = bad_files_num
        self._good_files_num = good_files_num
        self._files_num = bad_files_num + good_files_num
        self._good_files_proportion = good_files_num / (bad_files_num + good_files_num)
        self._bad_files_proportion = bad_files_num / (bad_files_num + good_files_num)
        self._most_informative_ngrams = SortedCollection(key=itemgetter(1))

    @staticmethod
    def _calculate_element(p_vj_ci, p_vj, p_ci):
        """
        calculates one element in caclculating total ig of a ngram
        """
        if p_ci == 0 or p_vj == 0 or p_vj_ci == 0:
            return 0
        return p_vj_ci * log((p_vj_ci / (p_vj * p_ci)), 10)

    def _get_ngram_ig(self, ngram):
        """
        calculates the ig of given ngram according to ig formula.
        """
        app_in_good_files = self._calculate_element(ngram.good_prop, ngram.proportion, self._good_files_proportion)
        app_in_bad_files = self._calculate_element(ngram.bad_prop, ngram.proportion, self._bad_files_proportion)
        absence_from_good_files = self._calculate_element((1 - ngram.good_prop), (1 - ngram.proportion),
                                                          self._good_files_proportion)
        absence_from_bad_files = self._calculate_element((1 - ngram.bad_prop), (1 - ngram.proportion),
                                                         self._bad_files_proportion)
        ig = app_in_bad_files + app_in_good_files + absence_from_bad_files + absence_from_good_files
        return ig

    def _add_ngram_to_collection(self, ngram_item):
        """
        adding given ngram to the sorted collection
        """
        self._most_informative_ngrams.insert(ngram_item)
        size = self._most_informative_ngrams.get_size()

        if size > Classifier.RETURN_SIZE:
            #remove the ngram with worst ig from collection
            self._most_informative_ngrams.remove(self._most_informative_ngrams[Classifier.RETURN_SIZE])

            #pprint(list(self._most_informative_ngrams))

    def add_new_ngram(self, ngram_str, good_appearances, bad_appearances):
        """
        create a new ngram and add it to collection
        """
        good_prop = good_appearances / self._good_files_num
        bad_prop = bad_appearances / self._bad_files_num
        prop = (good_appearances + bad_appearances) / self._files_num
        ngram = Ngram(ngram_str, prop, good_prop, bad_prop)
        ngram.ig = self._get_ngram_ig(ngram)
        ngram_item = (ngram.ngram_str, 1 - ngram.ig)
        self._add_ngram_to_collection(ngram_item)

    def get_most_informative_ngrams(self):
        """
        when we finish - return ngrams with best igs
        """
        classified_ngrams = [ngram[0] for ngram in list(self._most_informative_ngrams)]
        return classified_ngrams


class FileReader(object):
    """
    reads the ngrams file - ngram by ngram and parsing it
    """
    SEPERATOR = '|'
    DEC_BASE = 16
    PARAMETERS_LENGTH = 9
    FILE_END = ""

    def __init__(self, file_name):
        self._file_name = file_name
        self._good_files_num = 0
        self._bad_files_num = 0
        self._classifier = None

    def _parse_files_num(self, first_line):
        """
        parse the first line of the file that the number of "bad" and "good" files
        """
        args = first_line.split(FileReader.SEPERATOR.encode('hex'))
        good_files_num = int(args[0].decode('hex'), FileReader.DEC_BASE)
        bad_files_num = int(args[1][:-2].decode('hex'), FileReader.DEC_BASE)
        self._classifier = Classifier(bad_files_num, good_files_num)

    def read_ngrams(self):
        """
        the main function of this class , read each ngram and parse it
        """
        print "Reading ngrams from {file} and calculating IG for each ngram.".format(file=self._file_name)
        current_time = time.time()
        ngram_number = 1
        with open(self._file_name, 'rb') as fp:
            #read the first line - holding global info
            files_num = fp.readline().encode('hex')
            self._parse_files_num(files_num)

            #read an ngram
            ngram_data = fp.read(FileReader.PARAMETERS_LENGTH + Classifier.N)

            while ngram_data != FileReader.FILE_END:
                #parse ngram info
                ngram_hex = ngram_data.encode('hex')
                ngram_str = ngram_hex[:(Classifier.N * 2)]
                args = ngram_hex[(Classifier.N * 2):].split(FileReader.SEPERATOR.encode('hex'))
                ngram_good_appearances = int(args[1].decode('hex'), FileReader.DEC_BASE)
                ngram_bad_appearances = int(args[2].decode('hex'), FileReader.DEC_BASE)
                #creates ngram object for this ngram, calculating its ig and adding to collection
                self._classifier.add_new_ngram(ngram_str, ngram_good_appearances, ngram_bad_appearances)

                new_time = time.time()
                if new_time - current_time > 5:
                    current_time = new_time
                    print "Calculated ig for {number} ngrams.".format(number=ngram_number)

                ngram_data = fp.read(FileReader.PARAMETERS_LENGTH + Classifier.N)
                ngram_number += 1

            print "Done! Calculated ig for {number} ngrams.".format(number=ngram_number)

    def get_most_informative_ngrams(self):
        return self._classifier.get_most_informative_ngrams()