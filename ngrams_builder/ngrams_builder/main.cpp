//
//  main.cpp
//  ngrams_builder
//
//  Created by Amos Kleinberger on 2/14/14.
//  Copyright (c) 2014 Amos Kleinberger. All rights reserved.
//

#include <iostream>
#include <fstream>
#include <map>
#include <string>
#include <dirent.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h> 

using namespace std;

typedef pair<int, int> values;
typedef map<string, values> classMap;

static const int BENIGN_TYPE = 0;
static const int MALWARE_TYPE = 1;

static int NGRAM_SIZE = 0;
static int NUMBER_OF_FILES = 0;


bool mapToFile(const string &filename,const classMap &fileMap)     //Write Map
{
    cout << "Writing to file..." << endl << flush;
    ofstream ofile;
    ofile.open(filename.c_str(), ios::binary);
    
    if(!ofile)
    {
        return false;           //file does not exist and cannot be created.
    }
    
    ofile << NUMBER_OF_FILES << endl;
    
    for(classMap::const_iterator iter= fileMap.begin(); iter!=fileMap.end(); ++iter)
    {
        ofile.write(iter->first.c_str(), NGRAM_SIZE);
        
        ofile << "|" << get<0>(iter->second) << "|" << get<1>(iter->second);
        
        ofile << endl;
        
    }
    return true;
}

void readNgramsFromFile(const string& filePath, classMap& classification, int dirType) {
    static unsigned int BYTES_TO_READ = 1000 * 200; //read 200 kb each time
    char output[BYTES_TO_READ];
    
    cout << "Reading ngrams from file: " << filePath << endl << flush;
    NUMBER_OF_FILES ++;
    
    classMap currentMap;
    
    ifstream file;
    file.open(filePath);
    
    if (file.is_open()) {
        while (!file.eof()) {
            
            if(file.tellg() != 0) {
                file.seekg(-NGRAM_SIZE + 1, ios::cur);
            }
            
            file.read(output, BYTES_TO_READ);
            long readBytes = file.gcount();
            
            for (unsigned int i = 0; i < readBytes - NGRAM_SIZE + 1; i ++ ) {
                string current = string(&output[i], NGRAM_SIZE);

                classMap::iterator currentIt = currentMap.find(current);
                if(currentIt == currentMap.end()){
            
                    // the key is not in the current map, adding it.
                    values newValues(0, 0);
                    currentMap.insert(pair<string, values>(current, newValues));
                    
                    // checks if it is in the global
                    if(classification.find(current) == classification.end()) {
                        // it is not in the global map adding it.
                        if(dirType == BENIGN_TYPE) {
                            newValues.first = 1;
                        }
                        else {
                            newValues.second = 1;
                        }
                        classification.insert(pair<string, values>(current, newValues));
                    }
                    else {
                        // Searching for the key in the global map
                        classMap::iterator it = classification.find(current);
                        
                        if(dirType == BENIGN_TYPE){
                            get<0>(it->second) ++;
                        }
                        else {
                            get<1>(it->second) ++;
                        }
                    }
                }
            }
        }
    }
    file.close();
}

int iterateOverDirAndReadNgrams(const string& dir, classMap& classification, int dirType) {
    ifstream fin;
    string filepath;
    DIR *dp;
    struct dirent *dirp;
    struct stat filestat;
    
    cout << endl << "Getting files from: " << dir << endl << flush;
   
    dp = opendir( dir.c_str() );
    if (dp == NULL)
    {
        cout << "Error(" << errno << ") opening " << dir << endl;
        return errno;
    }
    
    while ((dirp = readdir( dp )))
    {
        filepath = dir + "/" + dirp->d_name;
        
        // If the file is a directory (or is in some way invalid) we'll skip it
        if (stat( filepath.c_str(), &filestat )) continue;
        if (S_ISDIR( filestat.st_mode ))         continue;
        
        readNgramsFromFile(filepath, classification, dirType);
        
    }
    closedir( dp );
    return 0;
}


int main(int argc, const char * argv[])
{
    if(argc < 5) {
        cout << "USAGE: " << argv[0] << " [ngram size] [benign_dir] [malware_dir] [out_dir]" << flush;
        exit(0);
    }
    
    cout << "Huji AI malware detection ngram builder" << endl << flush;
    
    NGRAM_SIZE = atoi(argv[1]);
    string benignFilePath = argv[2];
    string malwareFilePath = argv[3];
    string outputPath = argv[4];

    classMap classification;
    
    iterateOverDirAndReadNgrams(benignFilePath, classification, BENIGN_TYPE);
    iterateOverDirAndReadNgrams(malwareFilePath, classification, MALWARE_TYPE);
    
    outputPath.append("out.txt");
    mapToFile(outputPath, classification);
    
    cout << endl << "DONE! see output in: " << outputPath << endl;
    
    return 0;
}



