__author__ = 'Larrath'

from sklearn import tree
from ngram import NgramFromFileBuilder
from sklearn.feature_extraction import DictVectorizer

# The decision tree object is used to classify executable files into malicious and benign
# files. It checks for the presence of specific n-grams in the file and then, based on their
# presence, makes its decision.
# The decision tree is binary, as it checks the presence of n-grams.

#       ___Note about the decision tree algorithms___
# The Kolter & Maloof article appears to state that their research used the C4.5 algorithm (instead of ID3)
# in order to construct their decision tree. C4.5 was written by the same researcher who wrote ID3, and they
# both use the Gain Ratio metric in order to select which node to split on.
# The sklearn module DecisionTreeClassifier uses the CART algorithm, which is very similar to C4.5, apparently
# in particular when the decision tree is binary as in our case.
# Normally the CART algorithm uses a different metric than C4.5, however using Gain Ratio is also supported by
# the DecisionTreeClassifier as we have done.
# In a nutshell, even though we're not using exactly the same algorithm, our results should be virtually the same
# if we used the original C4.5 algorithm.

class DecisionTree:
    # The decision tree should have a node for each n-gram present in the collection passed to it.
    # According to the Kolter and Maloof paper, this size should be approximately 500.
    # The best decision trees will most likely be made using the best n-grams, so it is useful
    # to filter the n-gram collection appropriately before passing it to the constructor.

    # Parameters:
    #   ngram_collection:
    #       List of Dictionaries. Each dictionary in the list must contain every ngram contained by the sample.
    #   values_vector:
    #       List of sample values. In our case, "True" for Malware files and "False" for Benign files.
    #       [Will later see if we can simply label them "Malware" and "Benign" directly]
    #   ngram_size:
    #       Number of bytes in the n-gram. Used when the decision tree extracts ngrams from a given file.
    #   show_table:
    #       Boolean. If true, the constructor will create a DOT file that can be used to render a graphical
    #       representation of the decision tree.
    #   tree_graphic_output_file:
    #       File name to dump the DOT output into, if show_table is True.
    def __init__(self, ngram_collection, values_vector, ngram_size=4, show_tree=False, tree_graphic_output_file=None):
        assert len(ngram_collection) == len(values_vector)   # Each sample must be labelled.
        self.ngram_size = ngram_size
        # Initialize the DecisionTreeClassifier and determine the function used to select placement of nodes:
        # 'entropy' will use Information Gain and 'gini' (the default) will use Gini Impurity.
        self.tree = tree.DecisionTreeClassifier('entropy')

        # The DictVectorizer object converts and transforms the ngram_collection dictionary list
        # into a form that is usable by the DecisionTreeClassifier.
        # http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.DictVectorizer.html
        vectorizer = DictVectorizer()

        # Use the Vectorizer in order to transform the ngram_collection dictionary its usable form.
        prepared_ngram_collection = vectorizer.fit_transform(ngram_collection)

        self.tree.fit(prepared_ngram_collection.toarray(), values_vector)
        self.feature_names = vectorizer.get_feature_names()
        if show_tree:
            self.drawTree(tree_graphic_output_file)

    # Export the tree data in DOT format.
    # The output can be rendered into a PNG image by using the shell command:
    # "$ dot -Tpng $1 -o $2.png", where $1 is the output file name and $2 is the desired output PNG image name.
    # In case dot is not installed, get it through sudo apt-get install graphviz.
    def drawTree(self, target_file):
        with open(target_file, 'w') as output_path:
            tree.export_graphviz(self.tree, feature_names=self.feature_names, out_file=output_path)


    # classify the given file by decomposing it into ngrams and running it against the decision tree.
    def classify(self, filename):
        ngramBuilder = NgramFromFileBuilder(self.ngram_size)
        with open(filename, 'r') as f:
            ngrams = ngramBuilder.get_ngrams_from_single_file(f)
        return self.tree.predict(ngrams)
